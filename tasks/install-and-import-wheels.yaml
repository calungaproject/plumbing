apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: install-and-import-wheels
spec:
  description: >-
    Extracts the built Python wheels from the SNAPSHOT, installs them
    onto the specified TEST_IMAGE, and tries to import the packages.
  params:
    - description: The JSON string of the Snapshot under test
      name: SNAPSHOT
      type: string
    - description: The image used for smoke testing the built wheels
      name: TEST_IMAGE
      type: string
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    env:
      - name: SNAPSHOT
        value: $(params.SNAPSHOT)
      - name: IMAGES_TXT
        value: /var/workdir/images.txt
      - name: FILES_DIR
        value: /var/workdir/files
    volumeMounts:
      - name: workdir
        mountPath: /var/workdir
  steps:
    - name: get-image-urls
      image: quay.io/konflux-ci/buildah-task:latest@sha256:b82d465a06c926882d02b721cf8a8476048711332749f39926a01089cf85a3f9
      script: |
        #!/bin/bash
        set -euo pipefail

        jq -r '.components[].containerImage' <<< "${SNAPSHOT}" | tee "${IMAGES_TXT}"

    - name: extract-wheels
      image: quay.io/konflux-ci/oras:latest@sha256:1beeecce012c99794568f74265c065839f9703d28306a8430b667f639343a98b
      script: |
        #!/bin/bash
        set -euo pipefail

        AUTHFILE='/tmp/auth.json'
        mkdir -p "${FILES_DIR}"

        while read -r IMAGE; do
          echo "Processing ${IMAGE}"
          select-oci-auth "${IMAGE}" > "${AUTHFILE}"
          retry oras pull --registry-config "${AUTHFILE}" "${IMAGE}" -o "${FILES_DIR}"
        done < "${IMAGES_TXT}"

        ls -la "${FILES_DIR}"

    - name: install-and-import
      image: $(params.TEST_IMAGE)
      script: |
        #!/bin/bash
        set -euo pipefail

        if command -v dnf >/dev/null 2>&1; then
            dnf install -y python3.12
        elif command -v apt-get >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            apt-get update && apt-get install -y python3.12 python3.12-venv
        else
            echo "ERROR: No supported package manager found"
            exit 1
        fi

        # Setup the Python script to verify import
        cat <<'EOF' > /tmp/verify_import.py
        import importlib
        import importlib.metadata
        import sys
        from pathlib import Path

        # Extract distribution name from the filename
        wheel_filename = Path(sys.argv[1]).name
        dist_name = wheel_filename.split('-')[0].replace('_', '-').lower()

        try:
            dist = importlib.metadata.distribution(dist_name)
        except importlib.metadata.PackageNotFoundError:
            print(f'ERROR: Distribution "{dist_name}" not found in environment.')
            sys.exit(1)

        import_names = set()

        # Try to use top_level.txt if it exists
        tl_content = dist.read_text('top_level.txt')
        roots = set(tl_content.splitlines()) if tl_content else set()

        # Fallback to file list if top_level.txt is missing
        if not roots and dist.files:
            for p in dist.files:
                root = p.parts[0]
                # Skip metadata, hidden files, and files like 'setup.py' if they leaked in
                if not (root.endswith(('.dist-info', '.egg-info')) or root.startswith('.')):
                    # If it's a standalone .py file at root, use the stem; else use the folder name
                    import_names.add(Path(root).stem if root.endswith('.py') else root)
        else:
            # We have roots (from top_level.txt), now check for Namespace Packages
            for root in roots:
                # Normalize slashes for comparison
                files_list = dist.files or []
                has_init = any(
                    str(p).replace('\\', '/').endswith(f"{root}/__init__.py")
                    for p in files_list
                )

                if not has_init and files_list:
                    # It's a directory without an __init__.py.
                    # Only add sub-items if they contain actual importable code.
                    sub_packages = set()
                    for p in files_list:
                        # Only subdirectories of root are valid sub-packages
                        if len(p.parts) >= 3 and p.parts[0] == root:
                            sub_dir = p.parts[1]
                            # Use endswith to handle versioned .so files
                            if p.name == "__init__.py" or str(p).endswith(('.py', '.so', '.pyd')):
                                sub_packages.add(f"{root}.{sub_dir}")

                    if sub_packages:
                        import_names.update(sub_packages)
                        continue

                import_names.add(root)

        # Final Filter: Exclude known non-importable patterns like .libs
        final_names = {n for n in import_names if not n.endswith('.libs')}

        if not final_names:
            print(f'ERROR: No import names could be resolved for: {dist_name}')
            sys.exit(1)

        for name in sorted(final_names):
            if name == 'tests' or name.startswith('_'):
                print(f'Skipping internal/test module: {name}')
                continue
            try:
                print(f'Trying to import {name}...')
                importlib.import_module(name)
                print(f'Successfully imported {name}')
            except ImportError as e:
                print(f'ERROR: Failed to import {name}: {e}')
                sys.exit(1)
            except Exception as e:
                print(f'ERROR: An unexpected error occurred during import: {e}')
                sys.exit(1)
        EOF

        echo "Changing directory to ${FILES_DIR}"
        cd "${FILES_DIR}"

        shopt -s nullglob

        whl_files=(*.whl)
        if [ ${#whl_files[@]} -eq 0 ]; then
            echo "ERROR: No .whl files found in ${FILES_DIR}"
            exit 1
        fi

        for WHEEL in "${whl_files[@]}"; do
            if [ -f "$WHEEL" ]; then
                echo "=================================================="
                echo "Testing $WHEEL..."

                rm -rf /tmp/test-venv
                echo "Setting up virtual environment..."
                python3.12 -m venv /tmp/test-venv

                echo "Installing wheel..."
                if ! /tmp/test-venv/bin/pip install --no-index --find-links . "${WHEEL}"; then
                    echo "ERROR: Installation failed for $WHEEL"
                    exit 1
                fi

                echo "Verifying import..."
                /tmp/test-venv/bin/python /tmp/verify_import.py "${WHEEL}"

                echo "Test successful for $WHEEL"
            fi
        done

        echo "=================================================="
        echo "Successfully tested all wheels!"
