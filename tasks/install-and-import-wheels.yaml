apiVersion: tekton.dev/v1
kind: Task
metadata:
  name: install-and-import-wheels
spec:
  description: >-
    Extracts the built Python wheels from the SNAPSHOT, installs them
    onto the specified TEST_IMAGE, and tries to import the packages.
  params:
    - description: The JSON string of the Snapshot under test
      name: SNAPSHOT
      type: string
    - description: The image used for smoke testing the built wheels
      name: TEST_IMAGE
      type: string
  volumes:
    - name: workdir
      emptyDir: {}
  stepTemplate:
    env:
      - name: SNAPSHOT
        value: $(params.SNAPSHOT)
      - name: IMAGES_TXT
        value: /var/workdir/images.txt
      - name: FILES_DIR
        value: /var/workdir/files
    volumeMounts:
      - name: workdir
        mountPath: /var/workdir
  steps:
    - name: get-image-urls
      image: quay.io/konflux-ci/buildah-task:latest@sha256:b82d465a06c926882d02b721cf8a8476048711332749f39926a01089cf85a3f9
      script: |
        #!/bin/bash
        set -euo pipefail

        jq -r '.components[].containerImage' <<< "${SNAPSHOT}" | tee "${IMAGES_TXT}"

    - name: extract-wheels
      image: quay.io/konflux-ci/oras:latest@sha256:1beeecce012c99794568f74265c065839f9703d28306a8430b667f639343a98b
      script: |
        #!/bin/bash
        set -euo pipefail

        AUTHFILE='/tmp/auth.json'
        mkdir -p "${FILES_DIR}"

        while read -r IMAGE; do
          echo "Processing ${IMAGE}"
          select-oci-auth "${IMAGE}" > "${AUTHFILE}"
          retry oras pull --registry-config "${AUTHFILE}" "${IMAGE}" -o "${FILES_DIR}"
        done < "${IMAGES_TXT}"

        ls -la "${FILES_DIR}"

    - name: install-and-import
      image: $(params.TEST_IMAGE)
      script: |
        #!/bin/bash
        set -euo pipefail

        if command -v dnf >/dev/null 2>&1; then
            dnf install -y python3.12
        elif command -v apt-get >/dev/null 2>&1; then
            export DEBIAN_FRONTEND=noninteractive
            apt-get update && apt-get install -y python3.12 python3.12-venv
        else
            echo "ERROR: No supported package manager found"
            exit 1
        fi

        # Setup the Python script to verify import
        cat <<'EOF' > /tmp/verify_import.py
        import importlib
        import importlib.metadata
        import sys
        from pathlib import Path

        wheel_filename = Path(sys.argv[1]).name
        dist_name = wheel_filename.split('-')[0].replace('_', '-').lower()

        try:
            dist = importlib.metadata.distribution(dist_name)
        except importlib.metadata.PackageNotFoundError:
            print(f'ERROR: Distribution "{dist_name}" not found in environment.')
            sys.exit(1)

        import_names = set()
        tl_content = dist.read_text('top_level.txt')
        roots = set(tl_content.splitlines()) if tl_content else set()
        files_list = dist.files or []

        if not roots and files_list:
            # Fallback: Derive roots from file list if top_level.txt is missing
            for p in files_list:
                root = p.parts[0]
                # Filter metadata and explicitly private roots
                if not (root.endswith(('.dist-info', '.egg-info')) or root.startswith('.')):
                    # Check root privacy (handling both module.py and package/)
                    name = Path(root).stem if root.endswith('.py') else root
                    if not name.startswith('_'):
                        import_names.add(name)
        else:
            for root in roots:
                # 1. Global Guard: If the root itself is private, skip it entirely.
                if root.startswith('_'):
                    continue

                # 2. Check if the root is a standard package (has __init__.py)
                has_init = any(str(p).replace('\\', '/').endswith(f"{root}/__init__.py") for p in files_list)

                if not has_init and files_list:
                    # 3. It's a namespace. Find public importable paths.
                    possible_targets = set()
                    for p in files_list:
                        # Must be inside this root and be actual code
                        if p.parts[0] == root and str(p).endswith(('.py', '.so', '.pyd')):

                            # Determine the "Effective Name" for privacy checking
                            if p.name == '__init__.py':
                                # For 'pkg/_internal/__init__.py', the package name is '_internal' (parent dir)
                                # We know len(p.parts) >= 2 here because parts[0] is root
                                effective_name = p.parts[-2]
                            else:
                                # For 'pkg/_utils.py', the module name is '_utils'
                                effective_name = p.stem

                            # Skip if the effective name is private
                            if effective_name.startswith('_'):
                                continue

                            # Construct path
                            parts = list(p.parts[:-1])
                            if p.name != "__init__.py":
                                parts.append(p.stem)

                            if parts:
                                possible_targets.add(".".join(parts))

                    if possible_targets:
                        # 4. Prefer shortest paths (top-most public packages)
                        for target in sorted(possible_targets, key=len):
                            if not any(target.startswith(existing + ".") for existing in import_names):
                                import_names.add(target)
                        continue

                    # 5. Safety Net: Empty namespace or all children were private.
                    continue

                # If it had an __init__ (standard package), just add the root.
                import_names.add(root)

        final_names = {n for n in import_names if not n.endswith('.libs')}

        if not final_names:
            print(f'ERROR: No import names could be resolved for: {dist_name}')
            sys.exit(1)

        for name in sorted(final_names):
            if name == 'tests' or name.startswith('_'):
                print(f'Skipping internal/test module: {name}')
                continue
            try:
                print(f'Trying to import {name}...')
                importlib.import_module(name)
                print(f'Successfully imported {name}')
            except ImportError as e:
                print(f'ERROR: Failed to import {name}: {e}')
                sys.exit(1)
            except Exception as e:
                print(f'ERROR: An unexpected error occurred during import: {e}')
                sys.exit(1)
        EOF

        echo "Changing directory to ${FILES_DIR}"
        cd "${FILES_DIR}"

        shopt -s nullglob

        whl_files=(*.whl)
        if [ ${#whl_files[@]} -eq 0 ]; then
            echo "ERROR: No .whl files found in ${FILES_DIR}"
            exit 1
        fi

        for WHEEL in "${whl_files[@]}"; do
            if [ -f "$WHEEL" ]; then
                echo "=================================================="
                echo "Testing $WHEEL..."

                rm -rf /tmp/test-venv
                echo "Setting up virtual environment..."
                python3.12 -m venv /tmp/test-venv

                echo "Installing wheel..."
                if ! /tmp/test-venv/bin/pip install --no-index --find-links . "${WHEEL}"; then
                    echo "ERROR: Installation failed for $WHEEL"
                    exit 1
                fi

                echo "Verifying import..."
                /tmp/test-venv/bin/python /tmp/verify_import.py "${WHEEL}"

                echo "Test successful for $WHEEL"
            fi
        done

        echo "=================================================="
        echo "Successfully tested all wheels!"
